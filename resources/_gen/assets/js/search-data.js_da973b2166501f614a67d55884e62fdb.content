(function(){const pages=[{"idx":0,"href":"/software-development/","title":"Software Development","content":""},{"idx":1,"href":"/elixir/","title":"Elixir","content":""},{"idx":2,"href":"/blockchain/","title":"Blockchain","content":""},{"idx":3,"href":"/business/","title":"Business","content":""},{"idx":4,"href":"/life/","title":"Life","content":""},{"idx":5,"href":"/about/","title":"About","content":""},{"idx":6,"href":"/","title":"About","content":"Hi. My name is Unnawut. You may also know me by my Thai nickname, O (pronounced a neutral \u0026ldquo;Oh\u0026rdquo;).\nI\u0026rsquo;m currently working as a software engineer at OmiseGO on the Integration team. I make sure that concepts as fresh as blockchain and decentralized exchange are accessible by businesses and individuals worldwide. My primary work at OmiseGO is the development of the open-source, Elixir-based eWallet server.\nYou may find me on LinkedIn, Medium, TED, Facebook and Instagram.\nFor the geeks out there, you\u0026rsquo;ll probably know me better through Stack Overflow and Github.\nSecure ways to contact me can be found at keybase.io/unnawut.\n"},{"idx":7,"href":"/02-elixir/2019-10-05-genserver-registry-dynamic-supervisor-combined/","title":"GenServer, Registry, DynamicSupervisor. Combined.","content":" Originally published at dev.to.\nIn omisego/ewallet, we\u0026rsquo;re building/refactoring a TransactionTracker that listens to a huge number of transactions (think money transactions) that also happen to be residing in an external source that is slow to update (Hello, Ethereum).\nSo we need a way for us to:\n Run the trackers concurrently, so to enable massive amount of transaction tracking. Look up a running tracker, so we can reuse it for different purposes. Automatically restart a specific tracker that goes wonky, because with external sources, anything can go wrong.  With Elixir and OTP/BEAM behind the scene, we are able to solve the problem by utilizing 3 Elixir core features:\n GenServer for building long-running, concurrent tasks. Registry for looking up those running GenServer\u0026rsquo;s. DynamicSupervisor for monitoring those arbitrary number of GenServer\u0026rsquo;s, and automatically restart one when it goes wonky.  The problem If we were to implement our own custom wiring, we would have to do the following:\n Start a new tracker process (a GenServer) attached to a DynamicSupervisor. Register the tracker process with the registry. To invoke the process, lookup the registry for the process ID. Make sure the registry handles the process\u0026rsquo;s crash, and remove the process from the registry. Make sure the registry knows when the process is restarted and registers the new process ID back. Deregister the process from the registry when it shuts down.  That\u0026rsquo;s a lot of code for the registry, and a lot of code to wire up the GenServer, DynamicSupervisor and Registry together. Since there\u0026rsquo;s a lot of moving parts, our implementation and wiring could be very prone to errors. All of this represents very little business value.\nThe solution Because Elixir designed the GenServer, Registry and DynamicSupervisor to work together seamlessly, we are surprised by how few lines of code needed to wire these up together.\ndefmodule TransactionTracker do use GenServer @registry TransactionTracker.Registry @supervisor TransactionTracker.TrackerSupervisor def start(transaction_id) do opts = [ transaction_id: transaction_id, name: {:via, Registry, {@registry, transaction_id}} ] DynamicSupervisor.start_child(@supervisor, {__MODULE__, opts}) end def lookup(transaction_id) do case Registry.lookup(@registry, transaction_id) do [{pid, _}] -\u0026gt; {:ok, pid} [] -\u0026gt; {:error, :not_found} end end def start_link(opts) do {name, opts} = Keyword.pop(opts, :name) GenServer.start_link(__MODULE__, opts, name: name) end def init(opts) do state = %{ transaction_id: Keyword.fetch!(opts, :transaction_id), } {:ok, state} end #... end defmodule TransactionTracker.Application do use Application def start(_type, _args) do children = [ {Registry, keys: :unique, name: TransactionTracker.Registry}, {DynamicSupervisor, name: TransactionTracker.TrackerSupervisor, strategy: :one_for_one} ] Supervisor.start_link(children, name: TransactionTracker.Supervisor, strategy: :one_for_one) end end With above, we can now do a simple one-liner to start the tracker:\niex\u0026gt; TransactionTracker.start(\u0026#34;txn_01dp371w0fnjhf9z2tjebx4vr4\u0026#34;) {:ok, #PID\u0026lt;0.104.0\u0026gt;} This one-line call would automatically:\n Start a new TransactionTracker GenServer for the given transaction ID. Register the tracker with TransactionTracker.Registry. Register the tracker with TransactionTracker.TrackerSupervisor. Restart the tracker when it shuts down abnormally. Return the correct process ID lookup even after a tracker restart. Deregister the tracker on expected shutdown. Allow interactions with the process via the returned pid or by looking up: TransactionTracker.lookup(\u0026quot;txn_01dp371w0fnjhf9z2tjebx4vr4\u0026quot;)  And this is what happens with an abnormal exit.\niex\u0026gt; TransactionTracker.start(\u0026#34;txn_01dp371w0fnjhf9z2tjebx4vr4\u0026#34;) {:ok, #PID\u0026lt;0.157.0\u0026gt;} iex\u0026gt; {:ok, pid} = TransactionTracker.lookup(\u0026#34;txn_01dp371w0fnjhf9z2tjebx4vr4\u0026#34;) {:ok, #PID\u0026lt;0.157.0\u0026gt;} iex\u0026gt; :ok = GenServer.stop(pid, :its_a_crash) 17:25:49.286 [error] GenServer {TransactionTracker.Registry, \u0026#34;abcd\u0026#34;} terminating ** (stop) :its_a_crash Last message: [] State: %{transaction_id: \u0026#34;txn_01dp371w0fnjhf9z2tjebx4vr4\u0026#34;} iex\u0026gt; {:ok, restarted_pid} = TransactionTracker.lookup(\u0026#34;txn_01dp371w0fnjhf9z2tjebx4vr4\u0026#34;) {:ok, #PID\u0026lt;0.162.0\u0026gt;} iex\u0026gt; :sys.get_state(restarted_pid) %{transaction_id: \u0026#34;txn_01dp371w0fnjhf9z2tjebx4vr4\u0026#34;} You would see that the lookup returns the new process automatically, and the process holds the same state as the previous one. Just start the process with your ideal identifier and you\u0026rsquo;ll be able to access the process from anywhere, with guarantee that it\u0026rsquo;ll point you to the correct process even if the process got restarted and the process ID changed.\nIsn\u0026rsquo;t it pretty?\nConclusion By using Elixir\u0026rsquo;s GenServer, Registry and DynamicSupervisor, we\u0026rsquo;re able to reap the following benefits when running long-running tasks.\n A one-liner way to start a long-running process, encapsulating away the registry and supervisor. The process, when it goes woowoo, gets restarted automatically by the supervisor. The registry handles a process\u0026rsquo;s shutdown automatically, so no need to worry about deregistering dead processes. The process can be looked up via the registry with ease, using our own arbitrary identifier, and works across process crashes.  What do you think? Do you have better ways to manage long-running processes? Let me know!\n"},{"idx":8,"href":"/tags/","title":"Tags","content":""},{"idx":9,"href":"/tags/concurrency/","title":"concurrency","content":""},{"idx":10,"href":"/tags/elixir/","title":"elixir","content":""},{"idx":11,"href":"/tags/programming/","title":"programming","content":""},{"idx":12,"href":"/tags/tech/","title":"tech","content":""},{"idx":13,"href":"/02-elixir/2019-09-29-clean-reusable-test-helpers-elixir-macros/","title":"Clean and reusable test helpers with Elixir macros","content":" Originally published at dev.to.\nSometimes, seemingly redundant tests could serve as an assurance that our code works. While it\u0026rsquo;s possible to abstract away the tests to a higher level, it may mean sacrificing readability.\nIn this post, I\u0026rsquo;d like to suggest a way to create test helpers that can be reused easily and works seamlessly with ExUnit. While we generally avoid creating macros as the official guide says:\n Macros should only be used as a last resort. Remember that explicit is better than implicit. Clear code is better than concise code.\n I believe this post presents an exact use case where macros allow us to have explicit, concise and clean tests at the same time.\nThe problem To begin, let\u0026rsquo;s say we have two schemas called User and Account. Each of them contain a name field that should not be blank. We could add tests like this:\ndefmodule UserTest do use ExUnit.Case describe \u0026#34;insert/1\u0026#34; do #... test \u0026#34;fails when given a blank name\u0026#34; do {:error, changeset} = User.insert(%{name: nil}) assert changeset.errors == [{:name, {\u0026#34;can\u0026#39;t be blank\u0026#34;, [validation: :required]}}] end end end defmodule AccountTest do use ExUnit.Case describe \u0026#34;insert/1\u0026#34; do #... test \u0026#34;fails when given a blank name\u0026#34; do {:error, changeset} = Account.insert(%{name: nil}) assert changeset.errors == [{:name, {\u0026#34;can\u0026#39;t be blank\u0026#34;, [validation: :required]}}] end end end Imagine if you have a dozen of schemas, most of which will require a check for blank fields. How much of your test code will be redundant? And how incomprehensible it would be, as the test code gets larger and larger?\nInterim solution: Helper functions The interim solution we tried was by abstracting away the assertion into a helper function, like below:\ndefmodule TestHelper do def not_blank(schema, field) do {result, changeset} = schema.insert(%{field =\u0026gt; nil}) assert result == :error assert changeset.errors == [{field, {\u0026#34;can\u0026#39;t be blank\u0026#34;, [validation: :required]}}] end end defmodule UserTest do use ExUnit.Case import TestHelper describe \u0026#34;insert/1\u0026#34; do #... test \u0026#34;fails when given a blank name\u0026#34; do assert not_blank(User, :name) end end end defmodule AccountTest do use ExUnit.Case import TestHelper describe \u0026#34;insert/1\u0026#34; do #... test \u0026#34;fails when given a blank name\u0026#34; do assert not_blank(Account, :name) end end end While above works great, the problem is that it is still cluttered when you want many assertions in a single test case, or you rather prefer lean test cases by testing one thing at a time.\nThe real deal: Macros as test helpers Here\u0026rsquo;s how we use macros to generate clean test cases:\ndefmodule TestHelper do defmacro test_insert_prevent_blank(schema, field) do quote do test \u0026#34;fails when given a blank :#{unquote(field)}\u0026#34; do schema = unquote(schema) field = unquote(field) {result, changeset} = schema |\u0026gt; get_factory |\u0026gt; params_for(%{field =\u0026gt; \u0026#34;\u0026#34;}) |\u0026gt; schema.insert assert result == :error assert changeset.errors == [{field, {\u0026#34;can\u0026#39;t be blank\u0026#34;, [validation: :required]}}] end end end end With the macro above, we can now do one-liners like these:\ndefmodule UserTest do use ExUnit.Case import TestHelper describe \u0026#34;insert/1\u0026#34; do #... test_insert_prevent_blank(User, :name) end end defmodule AccountTest do use ExUnit.Case import TestHelper describe \u0026#34;insert/1\u0026#34; do #... test_insert_prevent_blank(Account, :name) end end And it is very readable when combined with other similar test helpers:\ndefmodule UserTest do use ExUnit.Case import TestHelper describe \u0026#34;insert/1\u0026#34; do test_insert_generate_uuid(User, :uuid) test_insert_prevent_blank(User, :name) test_insert_prevent_blank(User, :email) test_insert_prevent_duplicate(User, :email) test_insert_generate_timestamps(User) # Other schema-specific tests... end end Conclusion We have been using this test-helper-as-a-macro approach in our project at omisego/ewallet with satisfaction. It has worked well so far with the following benefits:\n One-liner tests. Helps optimize valuable screen estate for browsing through the tests. Meanwhile the tests still have their explicity, not being hidden away behind some higher-level abstraction. Not having to worry about human-error applying a change to the test behavior across the codebase. Even the test names are reflected by the macro. When a test fails, its error pinpoints to the exact assertion. The error messages are very clear, and the test name represents the assertion exactly. We\u0026rsquo;re not hacking how ExUnit works, relying purely on ExUnit\u0026rsquo;s public API.  If you find this approach interesting, you can find real-world examples of the helper macros at EWalletDB.SchemaCase, and usage at EWalletDB.RoleTest.\nWhat do you think? Do you find any drawback or a better solution? Let me know!\n"},{"idx":14,"href":"/tags/testing/","title":"testing","content":""},{"idx":15,"href":"/10-business/2019-09-28-psychology-of-money/","title":"[Article Review] The Psychology of Money by Morgan Housel","content":"This article, The Psychology of Money, was recommended to me by Ino Murko. It\u0026rsquo;s a great read on personal investment.\nThe author described 20 flaws, biases, and causes of bad behavior when people deal with money. Below are my favorite excerpts.\n \u0026ldquo;In no other field does someone with no education, no relevant experience, no resources, and no connections vastly outperform someone with the best education, the most relevant experiences, the best resources and the best connections [\u0026hellip;] Managing money isn’t necessarily about what you know; it’s how you behave. [\u0026hellip;] The finance industry talks too much about what to do, and not enough about what happens in your head when you try to do it.\u0026rdquo;\n \u0026ldquo;An overreliance on past data as a signal to future conditions in a field where innovation and change is the lifeblood of progress. The cornerstone of economics is that things change over time, because the invisible hand hates anything staying too good or too bad indefinitely.\u0026rdquo;\n \u0026ldquo;The problem with viewing crowds as evidence of accuracy when dealing with money is that opportunity is almost always inversely correlated with popularity.\u0026rdquo;\n \u0026ldquo;The first rule of compounding is to never interrupt it unnecessarily.\u0026rdquo;\n \u0026rdquo; \u0026lsquo;Don’t do anything\u0026rsquo; are the most powerful words in finance. But they are both hard for individuals to accept and hard for professionals to charge a fee for.\u0026rdquo;\n \u0026ldquo;What you don’t realize is that the traders moving the marginal price are playing a totally different game than you are. And if you start taking cues from people playing a different game than you are, you are bound to be fooled and eventually become lost, since different games have different rules and different goals.\u0026rdquo;\n \u0026ldquo;Because finance is entertaining in a way other things – orthodontics, gardening, marine biology – are not. Money has competition, rules, upsets, wins, losses, heroes, villains, teams, and fans that makes it tantalizingly close to a sporting event. But [\u0026hellip;] you’re both the fan and the player, with outcomes affecting you both emotionally and directly. Which is dangerous.\u0026rdquo;\n \u0026ldquo;Extrapolating the recent past into the near future, and then overestimating the extent to which whatever you anticipate will happen in the near future will impact your future. Most of the time, something big happening doesn’t increase the odds of it happening again. It’s the opposite, as mean reversion is a merciless law of finance.\u0026rdquo;\n \u0026ldquo;If you see someone driving a $200,000 car, the only data point you have about their wealth is that they have $200,000 less than they did before they bought the car. [\u0026hellip;] Wealth, in fact, is what you don’t see. It’s the cars not purchased. The diamonds not bought. The renovations postponed, the clothes forgone and the first-class upgrade declined. It’s assets in the bank that haven’t yet been converted into the stuff you see.\u0026rdquo;\n  If you find these excerpts resonate with you, check out the original article: The Psychology of Money by Morgan Housel.\n"},{"idx":16,"href":"/tags/business/","title":"business","content":""},{"idx":17,"href":"/tags/finance/","title":"finance","content":""},{"idx":18,"href":"/80-life/2019-05-04-koom-koom-coffee/","title":"Koom Koom — Good coffee beans at affordable prices","content":"First, a bold disclaimer that I\u0026rsquo;m no coffee expert, but I do have a difficult time finding coffee beans that I like. My coffee preference gradually moved towards bolder drinks, i.e. I started drinking coffee with iced mocha, then cappucino, then finally settling down with espresso.\nSince I started drinking espresso, I noticed I\u0026rsquo;ve become more picky about the bean. I suppose it\u0026rsquo;s to do with espresso being pretty much concentrated coffee, not diluted in milk or anything other than a small amount of water. And buying a bag of coffee beans only to find out that I dislike it after a shot brings much sadness to life.\nRecently I was recommened by an OmiseGO colleague, Noei, to Koom-Koom. When I asked for a coffee bean that is very low to no acidity for espresso, the store person recommended Doi Saket, a 100% Arabica from Chiang Mai. I bought that bean and was not disappointed. It\u0026rsquo;s pretty much a mid-to-dark roast, a little sweet, and does not taste sour at all.\n  Koom Koom Coffee (Ikea clipper not included :p)   Koom-Koom calls itself a wholesale shop, so the minimum order is 1kg. The price is very affordable though and orders are shipped twice a week. Doi Saket costed me 330 Baht for a kilo, plus 95 Baht shipping (shipping cost is billed exactly as quoted by the shipping company), so no big deal. My order arrived within a week, just in time before my Starbucks beans ran out.\nIf you are looking for a coffee bean for your espresso, and you like it with little to no acidity, this may be worth trying. Head out to their online shop to order.\nKoom-Koom Coffee — online store only.\n"},{"idx":19,"href":"/tags/life/","title":"life","content":""},{"idx":20,"href":"/80-life/2019-04-22-phil-vienna/","title":"Phil — My favorite cafe in Vienna","content":"Despite so many cafes in Vienna, Phil, in my opinion, is the best one by far. I came here for a few hours of relax and work for both days of my stay in Vienna.\n  Phil\u0026#39;s atmosphere at night   Phil calls itself a coffee shop, a bar, a book store, a vintage furniture store (most if not all furnitures used in the shop are available for sale), a small movie shop (sells DVDs) and a small record shop (sells vinyl).\nIt is located only a 4-minute walk from Museumsquartier subway in a relatively quiet district, makes it really easy to access and quite peaceful.\nThe fact that it is open from 9AM - 1AM is also a big plus (although last order is around midnight). Looking for hungry and a place to read a book in the morning? Phil is open. Looking for a beer and some night-owl work? Phil is open.\nTheir food is also delicious and comforting. Here\u0026rsquo;s a photo of Phil Sandwhich which I dearly loved.\n  Phil Sandwich   If you have some time to spend in Vienna and looking for a cafe to sit and relax, I recommend trying Phil out.\nPhil — Gumpendorfer Str. 10 - 12, 1060 Wien, Austria (Google Maps)\n"},{"idx":21,"href":"/tags/blockchain/","title":"blockchain","content":""},{"idx":22,"href":"/tags/ethereum/","title":"ethereum","content":""},{"idx":23,"href":"/03-blockchain/2018-02-26-ethereum-casper-sharding-karl-floersch/","title":"สรุปทอล์ก Ethereum, Casper และ Sharding โดย Karl Floersch","content":" Originally published at blog.omisego.network\n  เมื่อวานผมมีโอกาสไปร่วมงาน Asia-Pacific Ethereum Community Meetup ที่ตึก KX ของ ม.พระจอมเกล้าฯ บางมด ช่วงเช้ามีทอล์กของคุณ Karl Floersch ที่น่าจะเป็นทอล์กที่คนประทับใจมากที่สุดของวันนั้น(เคียงข้างทอล์กของ Vitalik Buterin) เลยอยากเขียนสรุปมาแบ่งปันให้เพื่อน ๆ ที่สนใจเกี่ยวกับพัฒนาการในอนาคตอันใกล้ของ Ethereum ครับ\nทอล์กของคุณ Karl Floersch แบ่งออกเป็น 3 ส่วน ซึ่งเป็น 3 องค์ประกอบหลักของ Ethereum ในอนาคตอันใกล้ ดังนี้:\n Ethereum Casper Sharding    Part 1: Ethereum  คนส่วนใหญ่ถ้าเคยได้ยินคำว่า Ethereum น่าจะเข้าใจว่ามันคือคอมพิวเตอร์ที่ร่วมกันประมวลผลทั่วโลก (World’s computer) หรือแพลตฟอร์มสำหรับทำ ICO แต่จริง ๆ แล้วมีคำนิยาม Ethereum ที่ดีกว่านั้น คุณ Karl กล่าวถึงเหตุการณ์แบล็คสวอน (Black Swan) หรือเหตุการณ์ร้ายแรงที่มีผลกระทบต่อระบบหรือองค์กรอย่างสิ้นเชิง แต่โอกาสที่จะเกิดขึ้นนั้นมีน้อยมาก ๆ เหมือนการค้นพบห่านที่มีสีดำ โดยมีอยู่ 3 เหตุการณ์ที่เป็นชนวนให้เกิด Ethereum ขึ้น: Black Swan 1: วิกฤตแฮมเบอร์เกอร์เมื่อปี 2008 ที่สถาบันการเงินในอเมริกาล้มลงเนื่องจากหนี้เสียจำนวนมาก จนรัฐบาลต้องออกมาอุ้มแต่นายแบงก์ก็ลอยนวลไปด้วยกำไรมหาศาล โดยที่เรามองไม่เห็นว่าพวกเขาทำอะไรกันอยู่ ไม่รู้ว่าเขาบริหารเงินของเราอย่างไร และเราไม่มีสิทธิ์เรียกร้องใด ๆ ทั้งสิ้น ทำให้ประชาชนจำนวนมากหมดศรัทธากับระบบการเงินแบบศูนย์กลาง Black Swan 2: Vitalik Buterin ผู้ร่วมก่อตั้ง Ethereum ผู้ชื่นชอบเล่น Warlock (Lvl. 60) ใน Word of Warcraft วันหนึ่งเจ้าของเกมอยู่ดี ๆ ก็ประกาศยกเลิกตัว Warlock ที่เขาเล่น เป็นการตอกย้ำถึงความย่ำแย่ของการบริหารแบบใช้ศูนย์กลาง (อันนี้เป็นตัวอย่างขำ ๆ) Black Swan 3: Twitter อยู่ดี ๆ ก็ปิด API ตนเอง ไม่ให้นักพัฒนาที่ทำแอพเชื่อมต่อกับทวิตเตอร์ดึงข้อมูลได้ ทำให้หลาย ๆ แอพที่ถูกใช้อย่างกว้างขวางต้องปิดตัวลงอย่างถาวร Ethereum จึงถูกสร้างขึ้นเพื่อให้เป็นระบบที่ทุกคนสามารถมีส่วนร่วม และตรวจสอบการทำงานภายในของมันได้ สามารถเชื่อใจในตัวระบบได้ว่าโค้ดที่เราเห็น ไม่ว่าจะเป็นโค้ดที่ใช้ส่งเหรียญ ETH ไปมา หรือ Smart Contract ต่าง ๆ จะถูกรันตามนั้นจริง ๆ และไม่มีใครมีสิทธิ์ที่จะล้มล้างกฎเกณฑ์ที่เขียนไว้ในโค้ดได้ (Vitalik เลือกที่จะไม่ต่อยอดจาก Bitcoin เนื่องจากปัญหาเสถียรภาพของทีม Bitcoin) ทีม Ethereum เชื่อว่า การที่จะลดจำนวนเหตุการณ์แบล็คสวอนได้นั้นอยู่ที่การขีดเส้นขอบเขตอำนาจนั้นอย่างชัดเจน และทำให้เส้นอำนาจนั้นสามารถถูกตรวจสอบได้โดยคนจำนวนมาก ICO และ Cryptokitties พิสูจน์ให้เห็นว่าเราสามารถใช้ เศรษฐศาสตร์คริปโต (cryptoeconomics) ในการสร้างความเชื่อใจกันระหว่างคนที่ไม่รู้จักกันได้ แต่ 2 สิ่งนั้นเป็นเพียงก้าวแรกที่น่าเบื่อเท่านั้น (boring first steps) คุณ Karl จึงนิยาม Ethereum ว่าเป็นแพลตฟอร์มสำหรับการประมวลผลทั่วไปที่สร้างสภาพแวดล้อมที่เอื้อต่อการบังคับใช้สัญญาอิเล็กทรอนิกส์ โดยที่เราสามารถเชื่อใจได้ว่าข้อสัญญาที่เขียนขึ้นด้วยโค้ดนั้นจะถูกบังคับใช้อย่างถูกต้อง    Part 2: Casper  ปัญหาของ Proof of Work: หลาย ๆ คนที่ติดตามข่าวสารบล็อกเชนน่าจะทราบกันดีว่าหนึ่งในข้อด้อยของบล็อกเชนในปัจจุบันคือการที่เหล่า validators (ผู้ตรวจสอบธุรกรรม) ต้องใช้พลังงานปริมาณมหาศาลเพื่อแข่งกันคำนวณโจทย์ทางคณิตศาสตร์ ใครที่ตอบโจทย์ได้เป็นคนแรก คนนั้นจะได้ค่าธรรมเนียมธุรกรรมนั้นไป (Proof of Work) ทำให้ทุกคนมีต้นทุนในการร่วมวง และมีความเสี่ยงในการเสียต้นทุน(ค่าไฟ)นั้นไป หากพยายามเล่นตุกติกกับระบบแล้วคนอื่นจับได้ Proof of Stake คือคำตอบ: ในระบบ Proof of Stake (ภายใต้โค้ดเนม Casper) แทนที่ validators จะแข่งกันโดยการผลาญไฟฟ้า ลอจิคของ Casper จะให้ validator วางเดิมพัน/มัดจำ เช่น ETH เพื่อเป็นคำสัญญาว่าจะประพฤติดี แล้วตัว Casper จะสุ่ม validator ขึ้นมาจำนวนหนึ่งเพื่อทำการโหวต หากมีการพยายามโกงโหวตเกิดขึ้นและ validator ถูกโหวตออก แทนที่คนโกงจะเสียค่าไฟฟ้าที่ใช้ในการคำนวณ (ซึ่งมีผลกระทบทางธรรมชาติ และทำให้ราคาไฟฟ้าสูงขึ้นสำหรับทุกคน) ก็จะเสีย ETH ที่วางเดิมพันไว้แทน ซึ่งเป็นวิธีการที่ Ethereum ได้เลือกที่จะใช้เพื่อเป็นแรงจูงใจให้คนประพฤติดีโดยไม่เสียทรัพยากรโลกโดยใช่เหตุ    สเต็ปปกติในการโหวตบน Casper   ซึ่งการ validate ด้วย Proof of Stake ก็มีปัญหาของมันเอง หลัก ๆ คือ Double Vote และ Surround Vote:\n  เดิมพันจะถูกหักจากคนที่พยายามจะโหวตหลายบล็อกพร้อมกัน   ส่วน Surround Vote นั้น คุณ Karl ข้ามไป จึงไม่แน่ใจว่าจริง ๆ แล้วมันทำงานยังไง (อ้าว งงด้วยคน)\n  เดิมพันจะถูกหักจากคนที่เคยโหวตบล็อกหนึ่งไปแล้ว แต่บล็อกต่อมาขัดแย้งกับที่เคยโหวตไป   เมื่อนำทั้งการป้องกัน double vote และ surround vote มารวมกัน ก็จะเห็นภาพบล็อกทุจริตที่ถูกตีตกตามภาพด้านล่างนี้\n  ตัวอย่างการโจมตีที่ล้มเหลวถึงแม้ height ของผู้โจมตีจะอยู่สูงกว่า เพราะบล็อกปลอมจะเข้าข่าย slashing conditions   Part 3: Sharding  คุณ Karl กล่าวว่า Sharding คือสปอตไลต์ของบล็อกเชนในปี 2018 เพราะปัจจุบันบล็อกเชนมีปัญหาด้าน scalability อย่างมาก ในความเป็นจริง เราสามารถสเกลบล็อกเชนได้การใช้บล็อกที่ใหญ่ขึ้น ใช้คอมพิวเตอร์ที่แรงขึ้น แต่จุดประสงค์ของ decentralized network คือการทำให้ทุกคนบนโลกสามารถมีส่วนร่วมในระบบนี้ได้ การสเกลด้วยคอมพิวเตอร์ที่ใหญ่ขึ้นนั่นหมายถึงการทำให้คนจำนวนน้อยลงสามารถมีส่วนร่วมกับระบบได้ ซึ่งไม่ตอบโจทย์การทำ decentralized network อย่างแน่นอน Sharding ในเฟสแรกจะมี 100 shards (แบ่งข้อมูลทั้งหมดออกเป็น 100 ส่วน) Validators ของแต่ละ shard จะถูกสุ่มขึ้นมาล่วงหน้า 5 บล็อกเพื่อให้เวลาดาว์นโหลดข้อมูลล่าสุดของ shard ที่ต้องตรวจสอบ Validators ของแต่ละ shard จะสร้าง collation header ซึ่งเป็นเหมือน block header ไว้เก็บข้อมูลสรุปของ shard นั้น ๆ แล้วส่งไปเก็บรักษาที่ root chain อีกที ทีม Ethereum เชื่อว่า ด้วยโปรเจกต์ที่กำลังดำเนินการอยู่ ทั้ง Casper, Sharding, Plasma และการออกแบบเศรษฐศาสตร์คริปโต จะทำให้เกิดแอพพลิเคชั่นที่ไม่มีศูนย์กลางและสเกลได้อย่างกว้างขวางเกิดขึ้นได้จริงๆ ตัว Sharding เองพลิกแพลงได้ไม่มาก แต่อีกส่วนหนึ่งที่จะทำให้การสเกลเกิดขึ้นได้จริงคือการให้ความรู้กับผู้ที่เขียน smart contract เพราะเทรนด์ตอนนี้คือการเขียน smart contract ที่ใหญ่สโคปขึ้นเรื่อย ๆ ซึ่งไม่จำเป็น เช่น เราต้องการสร้างระบบจัดเก็บรูปที่บิดเบือนไม่ได้ เราไม่จำเป็นต้องเซฟรูปไว้บนบล็อกเชน เราจะใส่เฉพาะ hash ของรูปนั้นแล้วเก็บข้อมูลไฟล์ไว้ที่ AWS ก็ยังได้ หรือจริง ๆ แล้วการเซฟรูปไว้ที่อื่น hash รูปทั้งหมดเข้าด้วยกัน และบันทึกเพียง hash เดียวไว้บนบล็อกเชนก็ยังได้เลย    ตัวอย่างการทำงานของ Sharding   Q\u0026amp;A ในช่วง Q\u0026amp;A คุณ Karl ได้ตอบคำถามที่ผมคิดว่าน่าสนใจอยู่ 2 คำถาม นั่นคือ\nQ: คุณคิดว่าจะมีเหตุการณ์ hard fork เพื่อแก้ไขการถูกแฮกอย่างที่เกิดขึ้นกับ DAO เมื่อปีที่แล้ว (2016) ที่กู้คืนเงินกว่าพันล้านบาทคืนอีกหรือไม่? A: ผมคิดว่าจะไม่มีเหตุการณ์ hard fork เพื่อแก้ไขการถูกแฮกเกิดขี้นอีก เพราะ ณ วันนี้เรามีผู้ร่วมในระบบเราเยอะขึ้นมาก ๆ ซึ่งแปลว่าการตกลงทำ hard fork เพื่อเหตุการณ์แบบนี้จะเกิดขึ้นยากขึ้นเรื่อย ๆ ซึ่งเป็นเรื่องดีเพราะแปลว่าระบบจะมีความแน่นอนมากยิ่งขึ้น\nQ: อะไรคือแรงที่ทำให้คุณหันมาสร้าง Ethereum ซึ่งเป็นกิจกรรมที่แตกต่างไปจากวัยรุ่นทั่วไปทำมาก ๆ ? (คุณ Karl เพิ่งอายุ 24 ในวันที่เขาขึ้นพูดเมื่อวาน) A: ผมคิดว่ามนุษยชาติของเรากำลังไปได้ค่อนข้างดีนะ แต่อินเทอร์เน็ตเองก็สร้างความท้าทายใหม่ ๆ ขึ้นมามากมายให้เราต้องจัดการ ยิ่งนับวันเรายิ่งเห็นองค์กรจำนวนน้อยลงแต่องค์กรเหล่านี้ผูกขาดอินเทอร์เน็ตมากขึ้นและมีอำนาจอย่างมหาศาล ในขณะที่เราก็กำลังย้ายชีวิตของเราขึ้นไปอยู่บนโลกออนไลน์มากขึ้น มันจึงสำคัญมากที่เราจะต้องทำให้อินเทอร์เน็ตเป็นพื้นที่เปิด และเป็นเจ้าของร่วมกันโดยทุกคน ไม่ใช่มีคนไม่กี่คนที่สามารถบังคับสวิตช์ได้ตามใจชอบ และถึงแม้เราจะขีดเส้นกำกับอำนาจศูนย์กลางได้ แต่ถ้าคนดูแลเส้นนั้นมีแต่คนที่อยู่ในซิลิคอนวัลเลย์ เราก็จะได้อำนาจแบบซิลิคอนวัลเลย์ มันจึงจำเป็นมากที่เราจะต้องทำให้อำนาจนี้กระจายออกไปให้ได้มากที่สุด ให้ทุกคนบนโลกได้เป็นเจ้าของระบบนี้ไปด้วยกัน\nอ้างอิง: https://youtu.be/jpmaMMAUDU0?t=1h2m55s\n"},{"idx":24,"href":"/90-about/donations/","title":"Donations","content":" Social and Environmental Issues Recurring  COTAP - 10 USD/month (~1 CO2-tonne/month) since Aug 2019  Software I rely on many of the quality software below to improve my life. Many of them helped me making a living for the past few years. The people behind these great products below generously release their full (or very close to full) featured software without strict obligations to pay.\nApart from my contributions to open source and social causes, these are direct monetary contributions that I have made so far towards those software projects. I hope to contribute more in the coming years.\nI am extremely grateful to live during this time. You have made this world a better place to live in.\nRecurring  iTerm2 - 5 USD/month since Dec 2017 Homebrew - 5 USD/month since Dec 2017  One-time  CreativeCommons - 20 USD (2018) MyEtherWallet - 10 DAI (2018) Etherscan - 10 DAI (2018) ETH Gas Station - 10 DAI (2018) Transmission - 10 USD (2017) VideoLAN - 10 USD (2017) SMS Backup+ - 5 USD (2017) Authenticator Plus - 1 USD (2017, the author does not accept any other amount) Sublime Text - 80 USD (2015, not quite donation but I consider it a voluntary payment) Wikipedia - 7 USD (2010), 7 USD (2014) Cyberduck - 5 EUR (2010)  Pending  byobu Sequel Pro Have I Been Pwned Vim Soda Reloaded Read the Docs Daniel Stenberge - The creator of curl  Projects I wish I could pay for (they\u0026rsquo;re not accepting payments)  Duplicity  "}];window.bookSearch={pages:pages,idx:lunr(function(){this.ref("idx");this.field("title");this.field("content");pages.forEach(this.add,this);}),}})();